# using DaggerWebDash
# import DaggerWebDash: LinePlot, GanttPlot
# using TimespanLogging
# using Dagger
# using Test

# ml = TimespanLogging.MultiEventLog()
# ml[:core] = TimespanLogging.Events.CoreMetrics()
# ml[:id] = TimespanLogging.Events.IDMetrics()
# #profile && (ml[:profile] = DaggerWebDash.ProfileMetrics())
# ml[:wsat] = Dagger.Events.WorkerSaturation()
# ml[:loadavg] = TimespanLogging.Events.CPULoadAverages()
# ml[:bytes] = Dagger.Events.BytesAllocd()
# ml[:mem] = TimespanLogging.Events.MemoryFree()
# ml[:esat] = TimespanLogging.Events.EventSaturation()
# ml[:psat] = Dagger.Events.ProcessorSaturation()
# lw = TimespanLogging.Events.LogWindow(5*10^9, :core)
# # FIXME: logs_df = DataFrame([key=>[] for key in keys(ml.consumers)]...)
# # ts = DaggerWebDash.TableStorage(logs_df)
# # push!(lw.creation_handlers, ts)
# d3r = DaggerWebDash.D3Renderer(8080) #; seek_store=ts)
# push!(lw.creation_handlers, d3r)
# push!(lw.deletion_handlers, d3r)
# push!(d3r, GanttPlot(:core, :id, :esat, :psat))
# # TODO: push!(d3r, ProfileViewer(:core, :profile, "Profile Viewer"))
# push!(d3r, LinePlot(:core, :wsat, "Worker Saturation", "Running Tasks"))
# push!(d3r, LinePlot(:core, :loadavg, "CPU Load Average", "Average Running Threads"))
# push!(d3r, LinePlot(:core, :bytes, "Allocated Bytes", "Bytes"))
# push!(d3r, LinePlot(:core, :mem, "Available Memory", "% Free"))
# #push!(d3r, GraphPlot(:core, :id, :timeline, :profile, "DAG"))
# ml.aggregators[:d3r] = d3r
# ml.aggregators[:logwindow] = lw
# ctx = Context(; log_sink=ml)
# Dagger.Sch.EAGER_CONTEXT[] = ctx
# fetch(Dagger.@spawn sleep(100))
# # run(pipeline(`curl -s localhost:8080/index.html`; stdout=devnull))


# include("../tasks_scheduling/tasks.jl")

# t = task_setup()
# println(collect(t))


using Dagger, DaggerWebDash, TimespanLogging

ctx = Context() # or `ctx = Dagger.Sch.eager_context()` for eager API usage
ml = TimespanLogging.MultiEventLog()

## Add some logging events of interest

ml[:core] = TimespanLogging.Events.CoreMetrics()
ml[:id] = TimespanLogging.Events.IDMetrics()
ml[:timeline] = TimespanLogging.Events.TimelineMetrics()
ml[:wsat] = Dagger.Events.WorkerSaturation()
ml[:loadavg] = TimespanLogging.Events.CPULoadAverages()
ml[:bytes] = Dagger.Events.BytesAllocd()
ml[:mem] = TimespanLogging.Events.MemoryFree()
ml[:esat] = TimespanLogging.Events.EventSaturation()
ml[:psat] = Dagger.Events.ProcessorSaturation()
# ...

# (Optional) Enable profile flamegraph generation with ProfileSVG
ml[:profile] = DaggerWebDash.ProfileMetrics()
ctx.profile = true

# Create a LogWindow; necessary for real-time event updates
lw = TimespanLogging.Events.LogWindow(20*10^9, :core)
ml.aggregators[:logwindow] = lw

# Create the D3Renderer server on port 8080
d3r = DaggerWebDash.D3Renderer(8080)

## Add some plots! Rendered top-down in order

# Show an overview of all generated events as a Gantt chart
push!(d3r, DaggerWebDash.GanttPlot(:core, :id, :esat, :psat; title="Overview"))

# Show various numerical events as line plots over time
push!(d3r, DaggerWebDash.LinePlot(:core, :wsat, "Worker Saturation", "Running Tasks"))
push!(d3r, DaggerWebDash.LinePlot(:core, :loadavg, "CPU Load Average", "Average Running Threads"))
push!(d3r, DaggerWebDash.LinePlot(:core, :bytes, "Allocated Bytes", "Bytes"))
push!(d3r, DaggerWebDash.LinePlot(:core, :mem, "Available Memory", "% Free"))

# Show a graph rendering of compute tasks and data movement between them
# Note: Profile events are ignored if absent from the log
push!(d3r, DaggerWebDash.GraphPlot(:core, :id, :timeline, :profile, "DAG"))

# TODO: Not yet functional
#push!(d3r, DaggerWebDash.ProfileViewer(:core, :profile, "Profile Viewer"))

# Add the D3Renderer as a consumer of special events generated by LogWindow
push!(lw.creation_handlers, d3r)
push!(lw.deletion_handlers, d3r)

# D3Renderer is also an aggregator
ml.aggregators[:d3r] = d3r

ctx.log_sink = ml
# ... use `ctx`

include("../tasks/oldAPI_tasks.jl")

t = task_setup(10)
println(collect(ctx, t))
